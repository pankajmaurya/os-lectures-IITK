<html>

<head>

<title>Lecture notes for CS330 (lecture - 28)</title>

</head>

<body text="#000000" link="#000000" vlink="#000000" background="..\bg3.gif">

<center>

<h2>

Page Replacement Policies

<p>
Lecture-28<br>
Operating Systems (CS330)</h2>
</center>



<h4>

Lecturer: Deepak Gupta<br>

Notes prepared by: Abhinav Pathak<br>

Lecture Date: October 10, 2004 

</h4>

</h4>


<!--
	Contents
-->

<a name= "content"></a>
<h4>Contents</h4>

<ul>
<li><a href="#PRP">Page Replacement Policies</a>
<li><a href="#OptPRP">Optimal Page Replacement Policy</a>
<li><a href="#fifo">FIFO</a>
<li><a href="#LocRef">Locality Of Reference</a>
<li><a href="#localglobal">Local v/s Global Page Replacement Policies</a>
<li><a href="#LRU">LRU: Least Recently Used Policy</a>
<li><a href="#LRUApp">LRU Approximations</a>
<li><a href="#AddRefBitAlgo">Addtional Reference Bit Algorithm</a>

</ul>
<hr>

<!--
	Section:	Introduction
-->
<h4>
About This Lecture
</h4>

<p>
In this lecture we will start examining some page replacement policies and their
related implementation issues.
</p>

<hr>

<!--
	Section:	Page Replacement Policy
-->

<a name= "PRP"></a>
<h4>Page Replacement Policies</h4>

<p>
A page replacement policy decides which page has to be evicted if no free pages 
are available in the memory. The policies are similar to those in cache, but 
while the replacement policy for the cache is implemented in hardware, the
page replacement policy has to be implemented by the operating system.
In general, we want the policy with the lowest number of page fault rate
on an average.  Also the storage and computation overheads for implementing
the policy should be as low as possible.

<p>The sequence of virtual page numbers (memory references) generated by the
execution of a program is called a <b>reference string</b>. We can evaluate a 
policy by running it on a particular reference string (assuming a certain
memory size) and computing the number of page faults.

<a href="#content"> Back to Contents</a></p><hr>


<!--
	Section:	Optimal Page Replacement Policy
-->

<a name= "OptPRP"></a>
<h4>Optimal Page Replacement Policy</h4>

<p>
The optimal page-replacement policy has the lowest page fault rate of all 
policies for any given reference string and any given memory size. The optimal
policy is to replace the page that will be used after the longest time in the
future.  Clearly this policy cannot be implemented but serves as a useful
comparison point. 
<p>
The figure below shows the result of using the optimal policy on a specific
reference string.  The physical memory is assumed to have three frames none of
which have any useful contents to begin with (pure demand paging).

<center>
<img src="OptPolicy.jpg"> </img>
</center>

<p><a href="#content"> Back to Contents</a></p><hr>

<!--
	Section:	FIFO
-->

<a name= "fifo"></a>
<h4>FIFO: First In First Out Page Replacement</h4>

<p>
A FIFO algorithm associates with each page the time when that page was brought 
into memory. When a page must be replaced, the one which is oldest in the 
memory is replaced first. In actual implementation, a pointer pointing to the
frame table entry corresponding to the last frame replaced can be used.
<p>
A FIFO page replacement policy is easy to implement. But its performance is not 
always good. Suppose there is a page which was brought in early and is 
heavily used. Even though the page is in almost constant use, the FIFO policy
might page out this page.  The FIFO policy also suffers from a non-intuitive
phenomenon called the <i>Belady's Anomaly</i>.
Belady's Anomaly is a behavior exhibited by some page replacement policies
where the number of page faults may increase for the same reference string if 
the number of available frames is increased!  A reference string for which
Belady's anomaly is exhibited by the FIFO policy is shown in the figure below.
Observe that for the same reference string, the number of page faults
increases from 9 to 10 when the number of physical memory frames is increased
from 3 to 4.

<p>
<center>
<img src="FIFO.jpg"> </img>
</center>

<p><a href="#content"> Back to Contents</a></p><hr>


<!--
	Section:	Locality of Reference
-->

<a name= "LocRef"></a>
<h4>Locality Of Reference</h4>

<p>
Experimental observations show that when a process executes, it moves from 
locality to locality. A <i>locality</i> is a set of pages that are actively 
used together. A program is composed of several localities that may overlap. 
Thus a page that is recently used is expected to be used again quickly.
<br>
There are two types of locality of references:
<dl>
<dt><i>Spatial Locality</i>
<dd>If a particular memory location is used then the nearby 
memory locations are likely to get used soon.
<dt><i>Temporal Locality </i>
<dd>If a particular memory location is used now, then is
likely to be used again soon.
</dl> 

<p><a href="#content"> Back to Contents</a></p><hr>

<a name="localglobal"></a>
<h4>Local v/s Global Page Replacement Policies</h4>
A page replacement policy can be a global or a local policy.
In a global policy, a faulting process may be given a frame by evicting a
frame being used by some other process.  On the other hand, in a local policy, 
the victim frame is always selected from among the frames allocated to the
faulting process only.  Global policies are usually easier to implement, and
also give better performance.  Most operating systems therefore use global
page replacement policies.

<p><a href="#content"> Back to Contents</a></p><hr>


<!--
	Section:	LRU
-->
<a name= "LRU"></a>
<h4>LRU: Least Recently Used Policy</h4>

In the LRU page replacement policy, the least recently used frame (the frame
that has not been used for the longest period of time) is replaced.
Because of the locality of reference exhibited by most programs, the LRU page
replacement actually performs quite well in practice.  It can also be readily
shown that it does not suffer from the Belady's anomaly (the proof of this
fact is left as an exercise).  The following figure illustrates the LRU
algorithm on a specific reference string.

<p>
<center>
<img src="LRU.jpg"> </img>
</center>

An exact implementation of the LRU policy would, however, be expensive.  It
would require a timestamp (time of last use) to be held in every page table
entry, and updated (by the address translation hardware) on every memory access.
This would be expensive in terms of both time and space.  In practice,
therefore, LRU approximations are implemented.

<p><a href="#content"> Back to Contents</a></p><hr>

<!--
	Section:	LRU Approximations
-->
<a name= "LRUApp"></a>
<h4>LRU Approximations</h4>

<p>
For LRU approximations some hardware support is required. This support is
usually in the form of a reference bit in each page table entry. The reference 
bit for a page is set to 1 (if not already 1) by the hardware whenever the 
page is referenced.  Note that this has very little space and time overhead.
<p>
If the reference bit is not supported by the hardware, we can simulate it in 
software, using an idea similar to the simulation of the dirty bit (details
are left as an exercise). 
<p>

<p><a href="#content"> Back to Contents</a></p><hr>

<!--
	Section:	Additional Reference Bit Algorithm
-->
<a name= "AddRefBitAlgo"></a>
<h4>Additional Reference Bit Algorithm</h4>

<p>
This algorithm approximates the LRU policy by maintaining extra reference bits
(called history bits) for each physical frame in software. At regular intervals,
for each frame, we transfer the reference bit to the history bits discarding 
the least significant history bit as follows.
<blockquote>
history = (history &gt;&gt; 1) | R &lt;&lt; (<i>n</i>-1). 
</blockquote>
where <i>n</i> is the number of history bits maintained, and R is the current
reference bit for the page.  The reference bit in the page is cleared after
this transfer.  Note that a physical frame may correspond to multiple virtual
pages (if the frame is shared).  In this case, the R above would be a logical
OR of the reference bits for all such pages.
<p>
At any given time, the <i>i</i><sup>th</sup> most significant history bit 
indicates whether or not the page was used in the <i>i</i><sup>th</sup> past
interval.  When a victim frame is needed, the frame with the least history
value is selected.

<p>
The additional reference bits algorithm, though quite close to exact LRU, is 
not often used in practice because of the overhead of periodically updating 
the history bits. In practice, even more approximate algorithms that are more 
efficient are used.
</p>

<p><a href="#content"> Back to Contents</a></p><hr>


<!--
	Section:	Related links
-->

<p>
<h4>Related Links On Similar Topics</h4>         

<ul>
<li>
<a href="http://www.cs.ucsb.edu/~cs170/notes/virtualmem/">
UCSB Lecture Notes</a>
<li><a href="http://web.cse.iitk.ac.in/~cs330/www03-04/notes/demandpaging/demandpaging.htm">
Last year's CS330 lecture Notes</a>
<li><a href="http://www.itee.uq.edu.au/~comp3300/Tutorials/tutorial-8-notes.html">
Lecture Notes, The University of Queensland.</a>

</ul>

<p><a href="#content"> Back to Contents</a></p><hr>
</body>
</html>

