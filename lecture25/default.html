<html>
<head>
<title>Lecture notes for CS330 (lecture - 25)</title>
<!--
	replace n above by the lecture number
-->
</head>
<body text="#000000" link="#000000" vlink="#000000" background="..\bg3.gif">
<center>
<h2>
Memory Management 
<p>
Lecture-24<br>
Operating Systems (CS330)
</h2>
</center>

<h4>
Lecturer: Deepak Gupta<br>
Notes prepared by: Ayush Ghai<br>
Lecture Date: October 4, 2004
</h4>

<h4><a name=content></a>Contents</h4>

<ul> 
 <li> <a href="#intro">Introduction</a> </li>
 <li> <a href="#VM">Virtual Memory</a> </li>
 <li> <a href="#cont">Contiguous Allocation Scheme</a> </li>
 <li> <a href="#Seg">Segementation Scheme</a> </li>
</ul>
<hr>

<a name=intro>
<h4>Introduction</h4>

In this and the following few lectures, we will study the techniques used in
managing the physical memory of the system.  Memory is one of the most
important resources of a computer and good memory management can have a
tremendous impact on the overall system performance.  Due to advances in
hardware, memory is becoming cheaper, faster, and bigger.  But correspondingly,
new applications with larger memory requirements are becoming common.  Good
memory management, therefore, continutes to be, and will remain an important
aspect of operating system design.
<p>
In this set of lectures, we shall first look at techniques, both as hardware
level and at software level for implementing virtual memory.

<p><a href="#content">Back to Contents</a> 

<hr>

<h4><a name=VM>Virtual Memory</h4>
Recall the notion of virtual memory from the introductory lectures in the
course.  Addresses generated by the CPU are considered <i>virtual
addresses</i> and are translated by the CPU to physical addresses before being
placed on the memory bus.  This translation is driven by tables that are set
up by the operating system.  If the translation process results in an error,
an exception is raised by the CPU.

<h4>Advantages of Virtual Memory :</h4>
<ul>
<li><i>Protection: </i>
Virtual memory ensures that a user process cannot access any part of the
physical memory that is not explicitly assigned to it by the operating
system.  In particular, it cannot access any memory area that is being used by 
some other process, by the kernel itself, or is mapped to an I/O device.
<li>
While assigning addresses to symbols, the linker does not have to worry about
where the program will be loaded in physical memory when it is run.  Since
each process has its own independent (virtual) address space, the linker can
assign any addresses within this address space.
<li>
In conjunction with <i>Demand Paging</i> (to be studied a little later),
virtual memory allows a secondary storage devide, such as a disk, to be used
as an extension of physical memory.  This can lead to more efficient memory
usage.
</ul>

<h4>Virtual Address Space</h4>
The <i>virtual address space</i> of a process is the range of virtual
addresses that the process may generate.  The size of the virtual address
space depends on the hardware.  If virtual addresses are <i>n</i> bits wide,
the virtual address space consists of addresses from 0 to
2<sup><i>n</i>-1</sup>.  However, not all addresses in the virtual address
space may be accessible to the process.  That is, the operating system may
restrict the process to use only some portions of the virtual address space.
In general, the accessible part of the virtual address space need not be a
contiguous range of virtual addresses.

<p><a href="#content">Back to Contents</a> <p></p>
<hr>


<h4>Address Translation :</h4>
Let us now look at some simple schemes for translation of virtual addresses
to physical addresses.  Remember that the translation is carried out by the
hardware (under control of the OS).  Obviously, the translation process should
be as fast as possible.  Another issue is the overhead of storing the
translation tables should ideally be low.  In addition, the address
translation scheme should afford sufficient flexibility to the operating
system and linker etc., in deciding the accessible parts of the address space.
<p>
Let us start by looking at some simple translation schemes.
<p>
<h4><a name=cont>Contiguous Allocation</a></h4>
This is probably the simplest possible scheme for address translation.
In this scheme, the accessible part of the virtual address space is a 
single contiguous range of virtual addresses from 0 to <i>L-1</i>.
These virtual addresses map to contiguous physical addresses from
<i>S</i> to <i>S+L-1</i>.  Thus each process is allocated a contiguous chunk of
physical memory.  Allocation of physical memory can be done using first fit,
best fit, or worst fit algorithms.
<p>
Translation of virtual to physical addresses in this scheme is quite
straigtforward: for each process the OS maintains the <i>base</i> 
(<i>S</i> above) and <i>limit</i> (<i>L</i> above) values.  Special hardware
registers store the base and limit values for the current process. 
Given a virtual address <i>v</i>, the translation hardware first compares it
with <i>limit</i>.  If <i>v</i> is not smaller than <i>limit</i>, it is an 
illegal
virtual address and an exception is raised.  Otherwise the physical address
corresponding to <i>v</i> is simply <i>v</i> + <i>base</i>.
<p>
Regardless of the algorithm used for physical memory allocation, the main
problem with contiguous memory allocation is that, as processes are created
and terminated dynamically, the free memory may get <i>fragmented</i> into
small chunks that are too small to satisfy the needs of any process. This
problem is called <i>external fragmentation</i>.  Some fragments may indeed be
so small that more memory is required to keep track of such a fragment than
the size of the fragment itself!  In such cases, it may be desirable to
allocate slightly more memory to a process than it requires so as to avoid
very small fragments.  This leads to <i>internal fragmentation</i>,
<i>i.e.</i>, a process is allocated more memory than it needs (and hence
memory is wasted).  One solution to the problem of external fragmentation is
to periodically perform <i>compaction</i>.  The goal is to shuffle the
allocated memory chunks so that all free memory is available in a single large
block.  Compaction clearly has a large overhead as large amounts of data may
need to be moved around in memory.  Another problem with contiguous allocation
is that run-time requests for more memory from processes are difficult to
accommodate since free memory may not be available next to the already
allocated chunk.  The only solution is to copy all of the allocated memory
of the process to another larger chunk which is of course very expensive.

<h4><a name=Seg>Segmentation</a></h4>
In the segmentation scheme, the address space of a process is viewed as a
collection of variable sized <i>segments</i>.  Each segment occupies a
contiguous portion of the virtual address space.  Thus the virtual address
space may have inaccessible ``holes''.
This view allows the linker to
define separate segments for logically distinct program entities such as code,
global data etc.  The holes allow some segments to grow and shrink
dynamically.
<p>
With segmentation, a virtual address consists of a segment number, and an
offset within the segment.  Usually, of the <i>n</i> bits in the virtual
address, the most significant <i>k</i> bits denote the segment number and the
rest denote the offset within the segment.  Thus, there can be atmost
2<sup><i>k</i></sup> segments, each of which can be atmost
2<sup><i>n-k</i></sup> bytes in size.
<p>
The simplest way of implementing segmentation is to assume that each segment
occupies a contiguous portion of the physical memory as well.  However
segments that are contiguous in virtual address space need not be contiguous
to each other in physical memory.  For translation, a base and limit value
need to be stored each segment, to indicate the starting address in physical 
memory, and the size of the segment respectively.  These values are stored in
a <i>segment table</i> which is indexed by the segment number.  The segment
table may be stored in memory with its starting (physical) address stored in a
special register, or the table may be stored in a special, fast memory
dedicated for this purpose.
<p>
For translation, the segment number and offset are extracted from the 
virtual address.  The segment number is used as index in the segment table to
obtain the base and limit values for the segment.  The offset is next compared
with the limit value and an exception is raised if the offset is not less than
the limit.  Otherwise the physical address is the base value for the segment
plus the offset.  For most processes, not all possible segments need be
defined.  To take care of this, each segment table entry can carry a <i>valid
bit</i> specifying whether or not the segment is valid.
<p>
A major advantage of segmentation over simple contiguous allocation is that it
is possible to give the process different level of access to different
segments.  For example, read, write, and execute accesses rights may be
supported.  This can be implemented using <i>protection bits</i> in the
segment table entries.  The protection bits would be checked during the
translation process and an exception would be raised if the segment does not
permit the kind of access being requested by the process. 
The figure below shows a segment table with valid bits,
and protection bits for read, write, and execute accesses.
<p>
<center>
<img src="segmenttable.bmp"></img>
</center>
<p>
Another advantage of segmentation is that it is possible for two or more
processes to share some but not all parts of their address spaces.  For
example, it is common for multiple processes to be executing the same program.
With segmentation, the code segments for each of these processes can be marked
read-only and can map to the same copy of the program code in physical memory.
In such a case, the segment table entries (including the base and limit
values) for the code segments of each of these processes would be the same.
This can lead to a tremendous saving in the amount of physical memory needed.
A similar scheme can be used to implement shared memory based IPC.
<p>
Note, however, that since segments are variable sized and are allocated
contiguous chunks of physical memory, the problem of external fragmentation
still remains.  In the next lecture, we will look at a technique called
<i>paging</i> to eliminate this problem.

<p></p><a href="#content">Back to Contents</a> <p></p>
<hr>
